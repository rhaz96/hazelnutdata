<!DOCTYPE html>
<html lang="en-us">
    <head>
        

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Forecasting Capital BikeShare Ridership</title>
        
        <style>

    html body {
        font-family: 'Georgia', sans-serif;
        background-color: white;
    }

    :root {
        --accent: purple;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="/css/main.css">





<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Georgia">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/foundation.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
    
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.67.1" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">Forecasting Capital BikeShare Ridership</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/">Home</a></li>
                            
                                <li><a href="/about/">About</a></li>
                            
                                <li><a href="/post/">Posts</a></li>
                            
                                <li><a href="/project/">Projects</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/rhaz96/statisticalmusings"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/robertmhazell"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>Forecasting Capital BikeShare Ridership</h2>
        <h5></h5>
        
<a href="/tags/r"><kbd class="item-tag">R</kbd></a>

<a href="/tags/time-series"><kbd class="item-tag">time series</kbd></a>

<a href="/tags/projects"><kbd class="item-tag">projects</kbd></a>

<a href="/tags/machine-learning"><kbd class="item-tag">machine learning</kbd></a>


    </div>

    <div align="start" class="content">
<script src="/rmarkdown-libs/kePrint/kePrint.js"></script>


<center>
<img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/capitalbike.png" />
</center>
<center>
<p class="caption">
<a href="https://dc.curbed.com/2019/8/22/20828525/capital-bikeshare-dc-college-students-transportation-biking">Capital BikeShare docking station</a>
</p>
</center>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>I love to bike, especially during the spring and summer. As a New York City resident the city affords miles of urban bike paths, my favorite being the seamless connection between Riverside and Hudson River parks. Of course thousands (if not millions) of others enjoy biking throughout the country, and if you don’t own a bike you can rent one through various bike programs, like NYC’s <a href="https://www.citibikenyc.com/">Citi Bike</a> and Washington DC’s <a href="https://www.capitalbikeshare.com/">Capital BikeShare</a> (CB henceforth). The latter is the focus of this report.</p>
</div>
<div id="background-and-motivation" class="section level2">
<h2>Background and Motivation</h2>
<p>CB has maintained <a href="https://s3.amazonaws.com/capitalbikeshare-data/index.html">ridership data</a> since 2010, but I first came across their data on the UCI Machine Learning Repository <a href="https://archive.ics.uci.edu/ml/datasets/Bike+Sharing+Dataset">here</a> which featured data from 2011-2012. A more complete analysis of CB’s ridership requires more data, so UCI’s data will be merged with 2013-2017 data from CB’s website.</p>
<p>The objective is to create 30-day trip forecasts by comparing several competing time series models. This task is relevant to CB officials since they could predict how much revenue to expect for any 30 day period. While location-based data isn’t utilized in this analysis, using it could help identify areas needing increased bike availability. And although daily data is used here, hourly forecasts would enable cyclists to gauge and anticipate future bike demand.</p>
</div>
<div id="literature-review" class="section level2">
<h2>Literature Review</h2>
<p>Bike share programs are relatively new, but research on factors affecting ridership has been conducted. <a href="https://nacto.org/wp-content/uploads/2012/02/Bike-Lanes-and-Other-Determinants-of-Capital-Bikeshare-Trips-Buck-et-al-12-3539.pdf">Buck and Buehler 2011</a> have conducted research on CB ridership at the station level during CB’s first six months of operation. Using stepwise multiple regression model, they conclude average daily ridership is affected by the number of bike lines within 1/2 mile of a station, the number of Washington DC Alcohol Beverage Regulation Administration (ABRA) license holders, and the weighted average percentage of households with no access to an automobile (adjusted <span class="math inline">\(R^2\)</span> = 0.66, n=91).</p>
<p><a href="https://nacto.org/wp-content/uploads/2015/07/2012_Rixey_Station-Level-Forecasting-of-Bike-Sharing-Ridership.pdf">Rixey 2012</a> investigates the natural logarithm of monthly bike rentals across three bike share programs (including CB) from the first operating season of each, on a station basis using multiple regression. Rixey reduces his 19 candidate variables to 11 (plus an intercept) that include various socioeconomic and bike system architecture variables, yielding an adjusted <span class="math inline">\(R^2\)</span> of ~0.8.</p>
<p><a href="https://www.researchgate.net/profile/Khandker_Nurul_Habib2/publication/286379583_Effects_of_Built_Environment_and_Weather_on_Bike_Sharing_Demand_A_Station_Level_Analysis_of_Commercial_Bike_Sharing_in_Toronto/links/56684b7c08ae7dc22ad1c992/Effects-of-Built-Environment-and-Weather-on-Bike-Sharing-Demand-A-Station-Level-Analysis-of-Commercial-Bike-Sharing-in-Toronto.pdf">El-Assi, et al 2017</a> perform a similar types of analysis of Toronto’s bike share program, developing models for weekday, weekend, station origin, and station destination ridership. Adjusted <span class="math inline">\({R^2}\)</span> values hover around 0.66.</p>
<p><a href="https://pdfs.semanticscholar.org/8a39/c1df91725ac27ea0c413360c3592b911d17a.pdf">Wang et al 2012</a> use 19 total socioeconomic variables to develop a regression model for station level, 2011 ridership of the Nice Ride bike share program in Minneapolis. Notably no weather variables are included. They achieve an adjusted Adjusted <span class="math inline">\({R^2}\)</span> of approximately 0.87.</p>
<p>All of that research focuses more on identifying important variables and trends for ridership but not forecasting (extrapolating) future ridership. That is the focus of this analysis. It’s important to note high <span class="math inline">\(R^2\)</span> values don’t necessarily translate into accurate forecasts since models can overfit the data. That issue was not examined in their analyses, so it’s unsure how predictive their models are. However, the variables they used may be helpful additions to this analysis (at some later date).</p>
</div>
<div id="data-cleaning-and-feature-engineering" class="section level2">
<h2>Data Cleaning and Feature Engineering</h2>
<p>Data comes from three sources: UCI 2011-2012 data, historical weather data from NOAA for 2011-2017, and the CB ridership data from 2013-2017. We’ll go through each one; as the code is sufficiently commented, summaries of the data wrangling should suffice.</p>
<div id="uci-data-2011-2012" class="section level3">
<h3>UCI Data (2011-2012)</h3>
<p>We begin with the UCI data since it’s the quickest and serves as the baseline for how the remainder of data from 2013-2017 is handled.</p>
<p>Relevant revisions include:</p>
<ul>
<li>removing unnecessary weather and calendar variables - they’ll be replaced later on with other variables</li>
<li>converting relevant calendar variables into factor/categorical variables</li>
<li>converting weather data to their original, non-normalized scales</li>
<li>adding a week of the month column. This isn’t completely necessary now, but it’s used later to define/encode holiday dates in the 2013-2017 data</li>
</ul>
<pre class="r"><code># main libraries used; others will be loaded later
library(tswge)
library(fpp2)
library(lubridate)
library(dplyr)

############## Begin with UCI data ##############
# import 2011 and 2012 UCI data - will be merged with 2013-2017 data later
# change file path to match yours!
bikes_uci &lt;- read.csv(&quot;day.csv&quot;)
# remove atemp since it adds no info on top of temp
# remove season and yr - unnecessary calendar variables
# remove instant; remove workingday - weekday covers this
# remove weathersit - cumbersome to define; this is replaced with actual rain and snowfall data
bikes_uci &lt;- bikes_uci[, -c(1,3,4,8,9,11)]
# rename dteday to TripDate
colnames(bikes_uci)[1] &lt;- &quot;TripDate&quot;
# add 1 to weekday to make consistent with everyday understanding (1-7)
bikes_uci$weekday &lt;- bikes_uci$weekday+1
# convert calendar variables to factor variables
bikes_uci[, 2:4] &lt;- lapply(bikes_uci[, 2:4], factor)
# convert date column to ymd format
bikes_uci$TripDate &lt;- ymd(bikes_uci$TripDate)
# add weekofmon (needed later for the other years&#39; holiday calculations)
bikes_uci &lt;- bikes_uci %&gt;%
  mutate(weekofmon = ifelse(between(day(TripDate),1,7), 1,
                            ifelse(between(day(TripDate),8,14), 2,
                                   ifelse(between(day(TripDate),15,21), 3, 4))))
# un-normalize temp; normalization formula: (t-t_min)/(t_max-t_min); t_max = 39, t_min=-8
bikes_uci$temp &lt;- 47*bikes_uci$temp - 8
# convert temp from celcius to farenheit
bikes_uci$temp &lt;- bikes_uci$temp * 9/5 + 32
# un-normalize humidity; normalization formula: hum/100
bikes_uci$hum &lt;- 100*bikes_uci$hum
# convert weekofmon to factor
bikes_uci$weekofmon &lt;- as.factor(bikes_uci$weekofmon)</code></pre>
</div>
<div id="capital-bikeshare-data-2013-2017" class="section level3">
<h3>Capital BikeShare Data (2013-2017)</h3>
<p>The five years of data amount to nearly 16 million rows combined. Since UCI’s data is aggregated on a daily scale, we do the same here and include variables found in the UCI dataset. The time-consuming task here is encoding whether or not a date is a federal holiday, since some holidays change dates year to year. <a href="https://www.thoughtco.com/public-holidays-in-the-united-states-3368327">ThoughtCo</a> has a helpful page describing the “calendar rules” of federal holidays. By creating calendar-based columns like month, week of month, and day of the week, we can easily create a function that checks calendar conditions satisfying a federal holiday.</p>
<pre class="r"><code>library(data.table)
############## Now we import and clean the 2013-2017 data ##############
# data can be found from [here](https://www.capitalbikeshare.com/system-data)
# read as data.table for faster import
b &lt;- list.files(full.names = TRUE)[1:20] %&gt;% 
  lapply(fread) %&gt;% 
  bind_rows

# convert to a dataframe to use dplyr functions
b &lt;- data.frame(b)

# convert Start date to ymd:hms format
b$Start.date &lt;- ymd_hms(b$Start.date, tz=&quot;US/Eastern&quot;)

# make a new column just with the date only
b$TripDate &lt;- as.Date(b$Start.date, tz=&quot;US/Eastern&quot;)

# compute number of cyclists by date
cyclists &lt;- b %&gt;% 
  group_by(TripDate) %&gt;% 
  summarise(casual = sum(Member.type == &quot;Casual&quot;),
            registered = sum(Member.type == &quot;Member&quot;),
            cnt = casual+registered) %&gt;%
  mutate(weekday = wday(TripDate),
         mnth = month(TripDate),
         weekofmon = ifelse(between(day(TripDate),1,7), 1,
                            ifelse(between(day(TripDate),8,14), 2,
                                   ifelse(between(day(TripDate),15,21), 3, 4))))

## - Let&#39;s define federal holidays
# fixed holidays
holidays &lt;- c(ymd(&quot;2013/01/01&quot;) + years(0:4), # New Years Day 
              ymd(&quot;2013/12/25&quot;) + years(0:4), # Christmas Day
              ymd(&quot;2013/11/11&quot;) + years(0:4), # Veterans Day
              ymd(&quot;2013/07/04&quot;) + years(0:4)) # Independence Day

# holidays that change dates; weekday ranges from 1-7, with 1 being Sunday
# info taken from https://www.thoughtco.com/public-holidays-in-the-united-states-3368327 
is_moving_hday &lt;- function() {
  # Thanksgiving - fourth Thursday of November
  (cyclists$mnth == 11 &amp; cyclists$weekofmon == 4 &amp; cyclists$weekday == 5) |
    # MLK&#39;s Birthday - third Monday of January
    (cyclists$mnth == 1 &amp; cyclists$weekofmon == 3 &amp; cyclists$weekday == 2) |
    # George Washington&#39;s Birthday - third Monday of February
    (cyclists$mnth == 2 &amp; cyclists$weekofmon == 3 &amp; cyclists$weekday == 2) |
    # Memorial Day - fourth Monday of May
    (cyclists$mnth == 5 &amp; cyclists$weekofmon == 4 &amp; cyclists$weekday == 2) |
    # Labor Day - first Monday of September
    (cyclists$mnth == 9 &amp; cyclists$weekofmon == 1 &amp; cyclists$weekday == 2) |
    # Columbus Day - second Monday of October
    (cyclists$mnth == 10 &amp; cyclists$weekofmon == 2 &amp; cyclists$weekday == 2)  
}

# create a holiday column in cyclists data frame
cyclists &lt;- cyclists %&gt;%
  mutate(holiday = ifelse((is_moving_hday() | 
                            TripDate %in% holidays), 1, 0))
# convert calendar variables to factor variables
cyclists[, 5:8] &lt;- lapply(cyclists[, 5:8], factor)</code></pre>
</div>
<div id="noaa-historical-weather-data-2011-2017" class="section level3">
<h3>NOAA Historical Weather Data (2011-2017)</h3>
<p>CB doesn’t include weather related variables like UCI does (the data contributor(s) added them separately), so we need to find this ourselves. It’s a fair assumption that temperature and precipitation affect ridership patterns so this is well worth finding. The data is included in my repository but here’s how you can get it yourself:</p>
<div id="go-to-httpswww.ncdc.noaa.govcdo-webdatasets" class="section level6">
<h6>1) go to <a href="https://www.ncdc.noaa.gov/cdo-web/datasets" class="uri">https://www.ncdc.noaa.gov/cdo-web/datasets</a></h6>
</div>
<div id="under-local-climatological-data-select-search-tool" class="section level6">
<h6>2) under Local Climatological Data, select “Search Tool”</h6>
</div>
<div id="choose-state-then-virginia" class="section level6">
<h6>3) choose State, then Virginia</h6>
</div>
<div id="navigate-to-washington-reagan-national-airport-closest-weather-station-to-dc" class="section level6">
<h6>4) navigate to Washington Reagan National Airport (closest weather station to DC)</h6>
</div>
<div id="click-add-to-cart" class="section level6">
<h6>5) click Add to Cart</h6>
</div>
<div id="go-to-your-cart-in-the-upper-right-hand-side-of-the-webpage-click-view-all-items" class="section level6">
<h6>6) go to your cart in the upper right hand side of the webpage; click View All Items</h6>
</div>
<div id="choose-lcd-csv-select-dates-2011-01-01-to-2017-12-31-then-click-continue" class="section level6">
<h6>7) choose LCD CSV, select dates 2011-01-01 to 2017-12-31, then click Continue</h6>
</div>
<div id="fill-in-your-email-to-get-the-data-then-click-submit-order" class="section level6">
<h6>8) fill in your email to get the data, then click Submit Order</h6>
</div>
<div id="the-data-will-take-a-couple-of-minutes-to-be-sent-to-your-email" class="section level6">
<h6>The data will take a couple of minutes to be sent to your email</h6>
<p>We’re only concerned with the date, temperature, precipitation, snow, wind speed, and humidity. Everything else can be discarded.</p>
<p>After examining the data we see December 31 info is missing for 2011, 2013 and 2014 so these are searched manually from <a href="https://www.timeanddate.com/weather/usa/washington-dc/historic">timeanddate</a>, averaging the four six-hour interval values for the aforementioned weather variables (data is given for 12am, 6am, 12pm, and 6pm). Precipitation and snow values denoted as <code>T</code> (trace amounts) are replaced with 0.</p>
<pre class="r"><code>####### ---------- Include (dry-bulb) temperature, humidity, and precipitation data -------------###
# change file path to match yours
dc_weather &lt;- read.csv(&quot;dcweather.csv&quot;)
# non-blank temps represent daily averages
dc_weather &lt;- filter(dc_weather, !is.na(DailyAverageDryBulbTemperature))
# keep date, temp, and humidity columns - find their column numbers first
cols_keep &lt;- match(c(&quot;DATE&quot;,&quot;DailyAverageDryBulbTemperature&quot;,&quot;DailyAverageRelativeHumidity&quot;,
                     &quot;DailyAverageWindSpeed&quot;, &quot;DailyPrecipitation&quot;, &quot;DailySnowfall&quot;), 
                   colnames(dc_weather))
# remove everything else
dc_weather &lt;- dc_weather[, cols_keep]
# shorten/rename columns
colnames(dc_weather) &lt;- c(&quot;TripDate&quot;, &quot;temp&quot;, &quot;hum&quot;, &quot;windspeed&quot;, &quot;prec&quot;, &quot;snow&quot;)
# remove &quot;T&quot; and time values from date column; first convert to character
# equivalent to keeping elements 1-10 of the date string
dc_weather$TripDate &lt;- as.character(dc_weather$TripDate)
dc_weather$TripDate &lt;- substring(dc_weather$TripDate,1,10)
# now convert TripDate column to TripDate object
dc_weather$TripDate &lt;- ymd(dc_weather$TripDate)
# quick check of weather data (using summary function) reveals
# T values in prec and snow; T means trace amounts, so we&#39;ll substitute 0 for T
# info taken from https://www1.ncdc.noaa.gov/pub/data/cdo/documentation/GHCND_documentation.pdf
# first need to convert from factor to character - can&#39;t directly substitute from factor
dc_weather[, 5:6] &lt;- apply(dc_weather[, 5:6], 2, function(x) as.character(x))
# now make the substitution
for (i in 5:6) {
  # if any value in column i equals T, replace with 0, otherwise keep original value
  dc_weather[, i] &lt;- ifelse(dc_weather[, i] == &quot;T&quot;, &quot;0&quot;, dc_weather[, i])
}
# change prec and snow columns to numeric type
dc_weather[, 5:6] &lt;- apply(dc_weather[, 5:6], 2, function(x) as.numeric(x))
# missing 12/31 date for 2011, 2013, and 2014. insert rows into dc_weather
# find row number Dec 30 for &#39;11, &#39;13, and &#39;14.
dec_30s &lt;- which(month(dc_weather$TripDate) == 12 &amp; 
                 day(dc_weather$TripDate) == 30 &amp;
                 year(dc_weather$TripDate) %in% c(2011,2013,2014))

# create a small dataframe to hold Dec 31 info
dec_31_info &lt;- data.frame(TripDate = ymd(c(&quot;2011/12/31&quot;, &quot;2013/12/31&quot;, &quot;2014/12/31&quot;)),
                          temp = c(58,41,36),
                          hum = c(62,49,43),
                          windspeed = c(9,11,7),
                          prec = c(0,0,0),
                          snow = c(0,0,0)
)

# cut and paste together all the weather data
dc_weather &lt;- rbind(dc_weather[1:364, ], # 1/1/2011 - 12/30/2011
                     dec_31_info[1,], # 12/31/2011
                     dc_weather[365:1094, ], # 1/1/2012 - 12/30/2013
                     dec_31_info[2, ], # 12/31/2013
                     dc_weather[1095:1458, ], # 1/1/2014 - 12/30/14
                     dec_31_info[3,], # 12/31/14
                     dc_weather[1459:2919, ] # everything else
                     )</code></pre>
</div>
</div>
<div id="combining-all-three-datasets" class="section level3">
<h3>Combining all three datasets</h3>
<p>Finally, we unite all three datasets to obtain 2011-2017 ridership data. First, we replace the deleted UCI weather data with the 2011-2012 info from NOAA. Then we update the CB data by attaching the NOAA weather data from 2013-2017 to it. Finally, we horizontally stack the UCI and CB data (2011-2012 on top, 2013-2017 on the bottom) to make one complete dataset called <code>bikes</code>.</p>
<pre class="r"><code>############## combining all three datasets ##############
# add prec and snow values for 2011 and 2012 to bikes_uci
# these are the substitutes for weathersit
bikes_uci &lt;- dc_weather %&gt;% 
  filter(between(TripDate, &quot;2011/01/01&quot;, &quot;2012/12/31&quot;)) %&gt;%
  select(TripDate, prec, snow) %&gt;%
  merge(bikes_uci, by=&quot;TripDate&quot;, all=T)

# merge dc_weather and cyclists -- this adds on the weather data to cyclists
bikes_temp &lt;- merge(cyclists, dc_weather, by=&quot;TripDate&quot;)
# now we have all 2013-2017 data.  need to combine this with UCI 2011-2012 data
# first need to reorder columns of bikes_uci (or bike_temp)
cols_matched &lt;- match(colnames(bikes_temp), colnames(bikes_uci))
bikes_uci &lt;- bikes_uci[, cols_matched]
# now merge horizontally (stack UCI data on top of 2013-2017)
bikes &lt;- bind_rows(bikes_uci, bikes_temp)</code></pre>
</div>
<div id="final-data-cleaning" class="section level3">
<h3>Final Data Cleaning</h3>
<p>Curiously, all humidity data from October 2013 is missing (as well as for four other dates).</p>
<pre class="r"><code>bikes[which(is.na(bikes$hum)), c(1,4,9:11)]</code></pre>
<pre><code>       TripDate   cnt temp hum windspeed
1005 2013-10-01 10255   72  NA       5.0
1006 2013-10-02 10249   76  NA       5.8
1007 2013-10-03 10059   76  NA       4.3
1008 2013-10-04 10158   78  NA       3.2
1009 2013-10-05 10456   79  NA       4.6
1010 2013-10-06  9650   80  NA       8.8
1011 2013-10-07  5797   68  NA      12.3
1012 2013-10-08  9829   62  NA       8.2
1013 2013-10-09  6360   60  NA      12.7
1014 2013-10-10  2491   58  NA      13.4
1015 2013-10-11  1775   62  NA      11.0
1016 2013-10-12  5191   66  NA      11.2
1017 2013-10-13  5938   63  NA      10.8
1018 2013-10-14  8818   64  NA       6.7
1019 2013-10-15  9272   64  NA       3.6
1020 2013-10-16  9629   68  NA       4.9
1021 2013-10-17  9468   70  NA       7.7
1022 2013-10-18 10256   61  NA       6.6
1023 2013-10-19  9309   60  NA       6.9
1024 2013-10-20  8493   58  NA       8.7
1025 2013-10-21  8956   57  NA       7.1
1026 2013-10-22  8990   60  NA       7.3
1027 2013-10-23  7884   54  NA       8.0
1028 2013-10-24  7823   48  NA       9.0
1029 2013-10-25  7866   48  NA       8.9
1030 2013-10-26  7906   46  NA      10.1
1031 2013-10-27  7917   53  NA       5.5
1032 2013-10-28  8515   55  NA       3.3
1033 2013-10-29  8949   55  NA       2.7
1034 2013-10-30  8055   59  NA       3.6
1035 2013-10-31  8335   62  NA       8.1
1520 2015-02-28  3222   27  NA       5.1
2013 2016-07-09 12198   86  NA       8.4
2157 2016-11-30  6170   61  NA       6.0
2247 2017-02-28  7828   58  NA       4.9</code></pre>
<p>Fortunately we can use past values to impute missing data. The ACF plot below quantifies how strong current and past humidity values are correlated, such as ~ 0.5 correlation between a given day’s value and yesterday’s value.</p>
<pre class="r"><code>Acf(bikes$hum, lag.max = 30, main=&quot;&quot;)
rect(xleft=0.5, ybottom=0, xright=1.5, ytop=0.53, border=&quot;red&quot;,lwd=2)
arrows(x0=4, y0=0.45, x1=2, y1=0.45, angle=20, col=&quot;red&quot;, length=.1)
text(x=3.7, y=0.45, labels = c(&quot;Lag 1&quot;), pos=4, cex=.85)
title(&quot;Humidity Autocorrelations&quot;, line=1)</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>Using one day previous values of humidity would be great if we weren’t missing 31 consecutive days! However, if we assign a seasonality of 365 to humidity, decomposing the humidity data displays a strong annual pattern, as seen in the <code>seasonal</code> component below.</p>
<pre class="r"><code># remove NAs from humidity column
hum_2 &lt;- na.omit(bikes$hum)
# make into ts object
hum_2_ts &lt;- ts(hum_2, frequency = 365)
stl(hum_2_ts, s.window = &quot;periodic&quot;) %&gt;% autoplot() + xlab(&quot;Time (Years)&quot;) + theme_minimal()</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>So we resort to using last year’s date ( ~ 365 days) for each missing date since there’s evidence of annual seasonality. For example, we’ll use humidity from 10/12/2012 as a substitute for 10/12/2013. It’s quite natural to ask what last year’s value of something was if you’re missing this year’s data and have evidence of annual seasonality, as we do here.</p>
<pre class="r"><code>############## final data cleaning ##############
# find date of missing hum values and get the previous year&#39;s date
last_yrs &lt;- bikes[which(is.na(bikes$hum)), ]$TripDate - years(1)
# get the associated humidity values
last_hum &lt;- bikes %&gt;% 
  filter(TripDate %in% last_yrs) %&gt;%
  select(TripDate, hum)
# impute by first storing relevant row numbers
rows_to_impute &lt;- which(is.na(bikes$hum))
bikes[rows_to_impute, 10] &lt;- last_hum$hum
# to model trend (in MLR model), need to include time variable (Time)
# Time is simply the length of the time series (1:nrow(bikes))
bikes$Time &lt;- 1:nrow(bikes) </code></pre>
<p>Lastly, we create a variable named <code>Time</code> which ranges from 1 to the total number of rows in <code>bikes</code> 2553, which implies Day 1 through 2553 of the dataset. Later on we’ll use this to model trend in our regression models.</p>
</div>
<div id="summary" class="section level3">
<h3>Summary</h3>
<p>There’s a lot in this section! It reflects how many data science analyses go: 70-80% of time is spent data cleaning and feature engineering, and there’s even more of the latter later in the modeling stage as we improve model performance. For now let’s restate what we’ve done so far.</p>
<ul>
<li>Replace categorical weather info in the UCI dataset with numerical values of snow and precipitation from NOAA</li>
<li>Introduce week of month as an auxiliary feature, and use it alongside month of year to define federal holiday as a feature in the 2013-2017 data</li>
<li>Impute missing weather data missing from NOAA</li>
<li>Introduce a time variable to model trend (later in the analysis)</li>
</ul>
<p>At this point we can (finally) explore the data!</p>
</div>
</div>
<div id="exploratory-analysis" class="section level2">
<h2>Exploratory Analysis</h2>
<div id="data-dictionary" class="section level3">
<h3>Data Dictionary</h3>
<p>Before exploring, here’s a summary of all the variables and their meanings.</p>
<pre class="r"><code>library(kableExtra)
bike_variables &lt;- data.frame(Variable = c(&quot;TripDate&quot;, &quot;casual&quot;, &quot;registered&quot;, &quot;cnt&quot;, &quot;weekday&quot;, &quot;mnth&quot;, &quot;weekofmon&quot;, &quot;holiday&quot;, &quot;temp&quot;, &quot;hum&quot;, &quot;windspeed&quot;, &quot;prec&quot;, &quot;snow&quot;, &quot;Time&quot;),
                             Description = c(&quot;Date of record&quot;, &quot;Number of trips made by lower-tier membership plan riders&quot;, &quot;Number of trips made by upper-tier membership plan riders&quot;, &quot;Sum of the two previous columns&quot;, &quot;Day of the week. 1 = Sunday&quot;, &quot;Month of TripDate (1-12)&quot;, &quot;Week of month of the TripDate (1-4)&quot;, &quot;Is the TripDate a federal holiday? 1 = Yes&quot;, &quot;Temperature in Fahrenheit&quot;, &quot;Humidity expressed as a percent (maximum possible = 100)&quot;,&quot;Wind speed in miles per hour&quot;, &quot;Amount of precipitation (rain) in inches&quot;,&quot;Amount of snowfall in inches&quot;, &quot;Day Number (Day 1, Day 2, etc).  Used to model trend in regression models&quot;))

bike_variables %&gt;% kable() %&gt;% kable_styling(full_width = F, bootstrap_options = &quot;striped&quot;)</code></pre>
<table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Variable
</th>
<th style="text-align:left;">
Description
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
TripDate
</td>
<td style="text-align:left;">
Date of record
</td>
</tr>
<tr>
<td style="text-align:left;">
casual
</td>
<td style="text-align:left;">
Number of trips made by lower-tier membership plan riders
</td>
</tr>
<tr>
<td style="text-align:left;">
registered
</td>
<td style="text-align:left;">
Number of trips made by upper-tier membership plan riders
</td>
</tr>
<tr>
<td style="text-align:left;">
cnt
</td>
<td style="text-align:left;">
Sum of the two previous columns
</td>
</tr>
<tr>
<td style="text-align:left;">
weekday
</td>
<td style="text-align:left;">
Day of the week. 1 = Sunday
</td>
</tr>
<tr>
<td style="text-align:left;">
mnth
</td>
<td style="text-align:left;">
Month of TripDate (1-12)
</td>
</tr>
<tr>
<td style="text-align:left;">
weekofmon
</td>
<td style="text-align:left;">
Week of month of the TripDate (1-4)
</td>
</tr>
<tr>
<td style="text-align:left;">
holiday
</td>
<td style="text-align:left;">
Is the TripDate a federal holiday? 1 = Yes
</td>
</tr>
<tr>
<td style="text-align:left;">
temp
</td>
<td style="text-align:left;">
Temperature in Fahrenheit
</td>
</tr>
<tr>
<td style="text-align:left;">
hum
</td>
<td style="text-align:left;">
Humidity expressed as a percent (maximum possible = 100)
</td>
</tr>
<tr>
<td style="text-align:left;">
windspeed
</td>
<td style="text-align:left;">
Wind speed in miles per hour
</td>
</tr>
<tr>
<td style="text-align:left;">
prec
</td>
<td style="text-align:left;">
Amount of precipitation (rain) in inches
</td>
</tr>
<tr>
<td style="text-align:left;">
snow
</td>
<td style="text-align:left;">
Amount of snowfall in inches
</td>
</tr>
<tr>
<td style="text-align:left;">
Time
</td>
<td style="text-align:left;">
Day Number (Day 1, Day 2, etc). Used to model trend in regression models
</td>
</tr>
</tbody>
</table>
<p>Our variable of interest to predict is <code>cnt</code>.</p>
</div>
<div id="overall-daily-ridership" class="section level3">
<h3>Overall Daily Ridership</h3>
<p>The line plot below is interactive, so feel free to click and drag around your mouse to zoom in on any portion. We see a clear positive trend and annual seasonality in ridership – for example, people tend to ride more during the summer than winter months.</p>
<p>The tall upward peaks in 2014 and 2015 most likely reflect high turnout at the annual National Cherry Blossom Festival.</p>
<pre class="r"><code>ggplot(bikes, aes(TripDate,cnt)) + 
  geom_line(col=&quot;steelblue&quot;) +
  xlab(&quot;&quot;)+
  ylab(&quot;Total Trips&quot;)+
  scale_x_date(breaks = &quot;11 months&quot;) +
  ggtitle(&quot;Capital BikeShare Daily Trips (2011-2017)&quot;) +
  theme(panel.grid = element_blank(),
        plot.title = element_text(hjust=0.5, family = &quot;Georgia&quot;))</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
<div id="exploring-weather-variables-on-ridership" class="section level3">
<h3>Exploring Weather Variables on Ridership</h3>
<p>Below is a scatterplot matrix of continuous predictors (weather variables) plotted against each other and the response variable <code>cnt</code> (total number of trips). Some comments:</p>
<ul>
<li>No significant multicollinearity exists between the weather variables. This means regression coefficients for those variables should be stable</li>
<li>Only temperature is strongly correlated with trip numbers</li>
<li>Snowfall and precipitation negatively affect trips (as expected)</li>
</ul>
<pre class="r"><code>pairs(bikes[, c(4,9:13)], lower.panel = NULL, col=&quot;steelblue&quot;)</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
<div id="ridership-by-day-of-the-week" class="section level3">
<h3>Ridership by Day of the Week</h3>
<p>Trip patterns tend to fluctuate depending on day of week though not in a drastic way. Nevertheless people tend to ride more in the middle of the week (Wednesdays in particular, beginning in 2015) and less during the weekends.</p>
<pre class="r"><code>library(numform)
library(gganimate)
library(magick)
dow_animation &lt;- bikes %&gt;%
  group_by(weekday, Year = as.integer(year(TripDate))) %&gt;% 
  summarise(`Total Trips` = sum(cnt)) %&gt;%
  ggplot(aes(weekday, `Total Trips`)) + 
  geom_bar(stat = &quot;identity&quot;, fill=&quot;lightblue&quot;) +
  #geom_text(aes(label=paste0(round(`Total Trips`/1000), &quot;K&quot;)), vjust=1.6, size=3.5)+
  scale_x_discrete(labels = c(&quot;1&quot;=&quot;Sun&quot;, &quot;2&quot;=&quot;Mon&quot;, &quot;3&quot;=&quot;Tue&quot;,&quot;4&quot;=&quot;Wed&quot;,&quot;5&quot;=&quot;Thur&quot;,&quot;6&quot;=&quot;Fri&quot;,&quot;7&quot;=&quot;Sat&quot;))+
  scale_y_continuous(label=ff_thous(digits=2))+
  theme(panel.background = element_blank(),
        axis.ticks = element_blank()) +
  labs(title=&quot;Total Trips by Day of Week: {frame_time}&quot;,
       x = &quot;&quot;, y=&quot;Total Trips (in thousands)&quot;)+
  transition_time(Year)

dow_anim &lt;- animate(dow_animation, nframes = 50, renderer = magick_renderer())
# save as gif
anim_save(&quot;dayofweek.gif&quot;, dow_anim)</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/dayofweek.gif" /></p>
</div>
</div>
<div id="modeling-forecasting-methodology" class="section level2">
<h2>Modeling &amp; Forecasting Methodology</h2>
<p>To reiterate, we want to make 30 day ahead trip predictions. We’ll explore several models using (virtually) all of 2011-2016 as training data and an expanding window with a seven day skip period for 2017 as our test data. That was a mouthful. To rephrase, initial model parameters are estimated beginning with all 2011-2016 data. When it comes time to test, the training set is expanded to re-estimate model parameters. Here’s a tabular look at what the training and test sets look like.</p>
<p>It’s fixed origin since the training set always begins at 1/8/2011. We need to skip 1/1/2011 - 1/7/2011 since (spoiler alert) one of the later models uses a lag of 7 of <code>cnt</code> and we want to make model comparisons on the same test sets. We also skip seven days for subsequent training sets since it’d take much more time to run all possible models. For example, instead of making our second training set 1/8/2011 - 1/1/2017 (one day after 12/31/2016) we make it 1/8/2011 - 1/8/2017. So we sidestep having additional training sets 1/8/2011-1/1/2017, 1/8/2011-1/2/2017, … , 1/8/2011-1/7/2017. Test sets are always 30 days long. In total we have 42 training and test sets, created using the <code>createTimeSlices</code> function in the <code>caret</code> package.</p>
<p>The RMSE (root mean square error) and RMSLE (root mean square log error) is used to evaluate models. These metrics are different from each other in that RMSLE penalizes underestimates more stronger than overestimates, whereas RMSE sees both equally. However, both are used since some models have drastically lower RMSEs but almost identical RMSLEs. In a bike share context it’s logical to view underestimates more harshly than overestimates, that’s why RMSLE is considered in this analysis alongside RMSE.</p>
<p>After the 42 RMSE and RMSLE values are calculated from a model we take the <em>median</em> of RMSE since a couple “bad” forecasts can quite skewer the true performance of our model, giving a false impression. We’ll use the <em>mean</em> of the RMSLEs since the RMSLE doesn’t suffer from that skewering.</p>
<pre class="r"><code>library(caret)
# use 2011-2016 for fitting model parameters; 2017 testing
bikes_train &lt;- bikes %&gt;% filter(between(TripDate, &quot;2011/01/08&quot;, &quot;2016/12/31&quot;))
bikes_test &lt;- bikes %&gt;% filter(between(TripDate, &quot;2017/01/01&quot;, &quot;2017/12/31&quot;))

bikes_adj &lt;- bikes[8:2553, ]
# create training and test splits
bike_splits &lt;- createTimeSlices(bikes_adj$cnt,
                                initialWindow = 2181, # row number of 12/31/2016
                                horizon = 30,
                                fixedWindow = F,
                                skip=7)</code></pre>
</div>
<div id="model-1-multiple-linear-regression-mlr-with-autocorrelated-residuals" class="section level2">
<h2>Model 1: Multiple Linear Regression (MLR) with autocorrelated residuals</h2>
<p>The pure time series ARIMA model doesn’t take advantage of the other variables in our dataset. A regression model can. Regression with time series data tends to create serially correlated residuals, violating a key MLR assumption. This is usually remedied by <em>simultaneously</em> computing the regression coefficients and residual structure. The seasonal period limitation of 350 in <code>auto.arima</code> (which performs the simultaneous calculations) doesn’t allow for this. As an alternative, we create two forecasts: 30 day forecasts from the “raw” MLR model and 30 days forecasts of the MLR’s residuals. Those are summed to create ridership forecasts.</p>
<div id="selecting-predictors" class="section level3">
<h3>Selecting Predictors</h3>
<p>We don’t have too many variables, so let’s see which predictors produce the highest adjusted <span class="math inline">\(R^{2}\)</span> and the lowest AIC. Using <code>weekofmon</code> as a predictor would be misleading since the fourth week has more than seven days most of the time. In the dataset nearly 200 extra days belong in the fourth week, so these extra days artificially inflate ridership numbers.</p>
<pre class="r"><code>table(bikes$weekofmon)</code></pre>
<pre><code>
  1   2   3   4 
588 588 588 789 </code></pre>
<pre class="r"><code>library(olsrr)
bike_reg &lt;- lm(cnt ~ weekday+mnth+holiday+temp+hum+windspeed+prec+snow+Time, 
               data=bikes_train)
all_regs &lt;- ols_step_all_possible(bike_reg)

# using highest adj R^2
best_r2 &lt;- all_regs %&gt;% arrange(desc(adjr))
best_r2[1:5, c(2:3,5)] %&gt;% 
  kable(caption = &quot;Predictors for best Adjusted R-Squared&quot;,) %&gt;%
  kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F) %&gt;%
  row_spec(1, bold = T, color = &quot;white&quot;, background = &quot;teal&quot;)</code></pre>
<table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:unnamed-chunk-17">Table 1: </span>Predictors for best Adjusted R-Squared
</caption>
<thead>
<tr>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
predictors
</th>
<th style="text-align:right;">
adjr
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: teal !important;">
9
</td>
<td style="text-align:left;font-weight: bold;color: white !important;background-color: teal !important;">
weekday mnth holiday temp hum windspeed prec snow Time
</td>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: teal !important;">
0.8138955
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum windspeed prec Time
</td>
<td style="text-align:right;">
0.8138678
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum prec snow Time
</td>
<td style="text-align:right;">
0.8138655
</td>
</tr>
<tr>
<td style="text-align:right;">
7
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum prec Time
</td>
<td style="text-align:right;">
0.8138267
</td>
</tr>
<tr>
<td style="text-align:right;">
7
</td>
<td style="text-align:left;">
weekday mnth temp hum prec snow Time
</td>
<td style="text-align:right;">
0.8103576
</td>
</tr>
</tbody>
</table>
<pre class="r"><code># using lowest AIC
best_aic &lt;- all_regs %&gt;% arrange(aic)
best_aic[1:5, c(2:3,8)] %&gt;% 
  kable(caption = &quot;Predictors for best AIC&quot;,) %&gt;%
  kable_styling(bootstrap_options = &quot;striped&quot;, full_width = F) %&gt;%
  row_spec(1, bold = T, color = &quot;white&quot;, background = &quot;orange&quot;)</code></pre>
<table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;">
<caption>
<span id="tab:unnamed-chunk-17">Table 1: </span>Predictors for best AIC
</caption>
<thead>
<tr>
<th style="text-align:right;">
n
</th>
<th style="text-align:left;">
predictors
</th>
<th style="text-align:right;">
aic
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: orange !important;">
7
</td>
<td style="text-align:left;font-weight: bold;color: white !important;background-color: orange !important;">
weekday mnth holiday temp hum prec Time
</td>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: orange !important;">
37976.46
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum windspeed prec Time
</td>
<td style="text-align:right;">
37976.97
</td>
</tr>
<tr>
<td style="text-align:right;">
8
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum prec snow Time
</td>
<td style="text-align:right;">
37976.99
</td>
</tr>
<tr>
<td style="text-align:right;">
9
</td>
<td style="text-align:left;">
weekday mnth holiday temp hum windspeed prec snow Time
</td>
<td style="text-align:right;">
37977.63
</td>
</tr>
<tr>
<td style="text-align:right;">
6
</td>
<td style="text-align:left;">
weekday mnth temp hum prec Time
</td>
<td style="text-align:right;">
38016.67
</td>
</tr>
</tbody>
</table>
<p>While adjusted <span class="math inline">\(R^{2}\)</span> is a popular metric for regression, the AIC is usually used for forecasting. Since
adj <span class="math inline">\(R^{2}\)</span> for the best AIC model is virtually identical to that of the full model with all 9 variables, we’ll
use the lowest AIC model. Those variables are highlighted in green; those in red are excluded.</p>
<table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Variables
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">weekday</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">mnth</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: red !important;">weekofmon</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">holiday</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">temp</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">hum</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: red !important;">windspeed</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">prec</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: red !important;">snow</span>
</td>
</tr>
<tr>
<td style="text-align:left;">
<span style="     color: green !important;">Time</span>
</td>
</tr>
</tbody>
</table>
</div>
<div id="fitting-and-forecasting-model-1" class="section level3">
<h3>Fitting and Forecasting Model 1</h3>
<p>Fitting an MLR with the seven variables above produces residuals that evidence an s=364 seasonality and a need to perform first order differencing. The ACF residuals cuts off after lag 3 while the PACF (slowly) dampens to 0, which implies an MA(3) should be fit to the residuals. An MA(3) passes the Ljung-Box test (p-val of 0.176 with lag=30), strong evidence to conclude the MA(3) fit produces residuals resembling white noise. The ACF plot of the MA(3) gives visual confirmation. Since we took one seasonal and one nonseasonal difference and fit an MA(3) to the residuals, our final model is an MLR with an ARIMA(0,1,3)(0,1,0)[364] residual structure.</p>
<pre class="r"><code>bike_reg &lt;- lm(cnt ~ weekday+mnth+holiday+temp+hum+prec+Time, 
               data=bikes_train)

reg_364 &lt;- diff(bike_reg$residuals, lag=364)
reg_364_1 &lt;- diff(reg_364, 1)
#Acf(reg_364_1, lag.max = 30)
#Pacf(reg_364_1, lag.max = 30)
reg_364_1_est &lt;- est.arma.wge(reg_364_1, p=0, q=3, factor=F)
Acf(reg_364_1_est$res, lag.max=30, main=&quot;&quot;)
title(&quot;ACF after fitting ARIMA(0,1,3)(0,1,0)[364] to Model 1&#39;s Residuals&quot;, line=1)</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<pre class="r"><code>#ljung.wge(reg_364_1_est$res, p=0, q=3, K=30) # 0.176</code></pre>
<p>The forecasts yield a median RMSE of 2302.075 and a mean RMSLE of 0.269.</p>
<pre class="r"><code>rmses_mlr &lt;- c()
rmsle_mlr &lt;- c()
#42 is the number of train/test sets
for (i in 1:42) {
  rows_train &lt;- bike_splits$train[[i]]
  rows_test &lt;- bike_splits$test[[i]]
  fit_reg &lt;- lm(cnt ~ weekday+mnth+holiday+temp+hum+prec+Time, 
                data=bikes_adj, subset = rows_train)
  # perform first order and seasonal differencing
  reg_364_1 &lt;- diff(diff(fit_reg$residuals, 364), 1)
  # result is stationary, so now estimate parameters MA parameters
  reg_364_1_est &lt;- est.arma.wge(reg_364_1, p=0, q=3, factor=F)
  # get forecast of residuals
  reg_res_for &lt;- fore.aruma.wge(fit_reg$residuals, 
                                phi=reg_364_1_est$phi, 
                                theta=reg_364_1_est$theta,
                                d=1,
                                s=364,
                                n.ahead = 30,
                                limits=F, plot = F)
  
  # get forecast of raw MLR values
  reg_for &lt;- predict(fit_reg, newdata = bikes_adj[rows_test, selected])
  # add these forecasts together
  forecast_combined = reg_res_for$f + reg_for
  # calculate rmse
  err_rmse &lt;- Metrics::rmse(bikes_adj$cnt[rows_test], forecast_combined)
  rmses_mlr &lt;- append(rmses_mlr, err_rmse)
  # calculate rmsle
  err_rmsle &lt;- Metrics::rmsle(bikes_adj$cnt[rows_test], forecast_combined)
  rmsle_mlr &lt;- append(rmsle_mlr, err_rmsle)
  
  #rmse &lt;- sqrt(mean(forecast_combined - bikes_adj$cnt[rows_test])^2)
  #rmses_mlr &lt;- append(rmses_mlr, rmse)
}
#median(rmses_mlr)
#mean(rmsle_mlr)</code></pre>
</div>
</div>
<div id="model-2-gradient-boosted-regression-trees" class="section level2">
<h2>Model 2: Gradient Boosted Regression Trees</h2>
<p>All the models thus far considered only linear relationships. Tree-based methods like random forests and gradient boosted machines are non-parametric, exploiting non-linearities to creating custom if-then statements or rules for prediction (or classification) tasks. Gradient boosting trees are applied here to unlock further predictive accuracy.</p>
<p>Since boosting uses tree-based methods, it does not automatically account for time series data. This is important since each tree in boosting is created by bootstrapping the training data in a random fashion. Order matters in time series, so random sampling can destruct time dependencies within data. Another issue arising from standard tree methods is failure to extrapolate increasing (or decreasing) trend for forecasting tasks. The final predictions from each tree during model building are averages of the response variable from the training set. The test set, by contrast, will include values of the response variable outside the range of the training set. This leads to systematically underpredicting test set data if there’s positive trend, or systematically overpredicting if there’s negative trend. Check this <a href="https://medium.com/datadriveninvestor/why-wont-time-series-data-and-random-forests-work-very-well-together-3c9f7b271631">Medium post</a> for a visual example.</p>
<p>Our data has clear positive trend (see <a href="#overall-daily-ridership">Overall Daily Ridership</a>) section). To remedy the issues of extrapolation, the response variable is detrended using first-order differencing on the <code>cnt</code> variable (which is called <code>dif1</code>). The model and it’s predictions are based on the <code>dif1</code>, but the final predictions are back transformed to the original scale using the following formula:</p>
<p><span class="math inline">\(PredictedOriginal_{t+1} = PredictedDiff_{t+1} + Actual_t\)</span></p>
<p>In other words, tomorrow’s predicted ridership (on the original scale) is the sum of tomorrow’s predicted difference and today’s actual ridership. To remedy time-dependency issues, we’ll use lagged values of <code>dif1</code>. Using a lag of 7 is the equivalent of looking back over the last week (seven days) of ridership numbers to form future predictions. Using any other lag didn’t improve forecast accuracies. Like Model 2 other predictors like temperature and windspeed are included, except <code>Time</code> since `<code>cnt</code> is detrended. This model also includes first-differenced values of temperature; hence, we look at both a given day’s temperature and the temperature difference between that day and the previous day.</p>
<pre class="r"><code># new dataframe that includes differenced and lagged values of cnt
b2 &lt;- bikes %&gt;%
  select(cnt, weekday, mnth, holiday, temp, hum, windspeed, prec, snow, TripDate) %&gt;%
  mutate(dif1 = c(NA, diff(cnt,1)),
         lag1 = lag(dif1),
         lag2 = lag(dif1, 2),
         lag3 = lag(dif1, 3),
         lag4 = lag(dif1, 4),
         lag5 = lag(dif1, 5),
         lag6 = lag(dif1, 6),
         lag7 = lag(dif1, 7),
         dif_temp = c(NA, diff(temp,1))
  ) %&gt;% 
  filter(complete.cases(.))

# rolling window construction
bike_splits2 &lt;- createTimeSlices(b2$cnt,
                                 initialWindow = 2180, # row number of 12/31/2016
                                 horizon = 30,
                                 fixedWindow = F,
                                 skip=7)
library(gbm) # used for gradient boosting trees
n_mods &lt;- length(bike_splits2$train)
rmsle_boost &lt;- c() # store each RMSLE here
rmse_boost&lt;- c() # store each RMSE here
smape_boost &lt;- c() #store each SMAPE here
# for each of the 42 train/test sets

set.seed(100)
for(i in 1:n_mods){
  # this is where the original data and (differenced) predictions will be stored
  # will be reinitialized for each training iteration
  mod_df &lt;- NULL 
  rows_train &lt;- bike_splits2$train[[i]]
  rows_test &lt;- bike_splits2$test[[i]]
  mod_df &lt;- b2[c(rows_train, rows_test), ] # dataframe containing train and test values
  boost.bikes=gbm(dif1 ~ .-cnt-TripDate,
                  data=mod_df[rows_train, ], 
                  distribution=&quot;gaussian&quot;, n.trees=5000, interaction.depth=2)
  bike.boost.pred=predict(boost.bikes,newdata=mod_df[rows_test, ], n.trees=5000)
  mod_df &lt;- mod_df %&gt;% 
    mutate(Preds = c(boost.bikes$fit, bike.boost.pred))
  
  # store back-transformed predictions here
  bike_trans &lt;- c()
  for (i in rows_test){
    pred &lt;- mod_df[i, &quot;Preds&quot;] + mod_df[i-1, &quot;cnt&quot;]
    # make any negative predictions be 0
    if (pred &lt; 0) {pred &lt;- 0}
    bike_trans &lt;- append(bike_trans, pred)
  }
  #calculate RMSE
  err_rmse &lt;- Metrics::rmse(mod_df[rows_test, &quot;cnt&quot;], bike_trans)
  rmse_boost &lt;- append(rmse_boost, err_rmse)
  # calculate RMSLE
  err_rmsle &lt;- Metrics::rmsle(mod_df[rows_test, &quot;cnt&quot;], bike_trans)
  rmsle_boost &lt;- append(rmsle_boost, err_rmsle)
  # calculate SMAPE
  err_smape &lt;- Metrics::smape(mod_df[rows_test, &quot;cnt&quot;], bike_trans)
  smape_boost &lt;- append(smape_boost, err_smape)
}</code></pre>
<div id="model-2-results" class="section level3">
<h3>Model 2 Results</h3>
<p>This model significantly outperforms Model 1, further reducing the median RMSE from 2302 to 1642. Median accuracy is 87%. As evidenced in the mean RMSLE underpredictions are reduced, dropping from 0.269 to 0.2.</p>
<pre class="r"><code># Median GBM RMSE
paste0(&quot;Median RMSE: &quot;, round(median(rmse_boost),3))</code></pre>
<pre><code>[1] &quot;Median RMSE: 1642.325&quot;</code></pre>
<pre class="r"><code># Mean GBM RMSLE
paste0(&quot;Mean RMSLE: &quot;, round(mean(rmsle_boost),3))</code></pre>
<pre><code>[1] &quot;Mean RMSLE: 0.2&quot;</code></pre>
<pre class="r"><code># Median GBM SMAPE
paste0(&quot;Median SMAPE: &quot;, round(median(smape_boost), 2))</code></pre>
<pre><code>[1] &quot;Median SMAPE: 0.13&quot;</code></pre>
</div>
</div>
<div id="model-3-a-naive-model-the-baseline" class="section level2">
<h2>Model 3: A Naive Model – The Baseline</h2>
<p>Finally, we fit a baseline model that simply uses predicts next-day ridership to be that of the current day. Building complex models like the first two above doesn’t give us an idea of how much better they perform relative to simpler alternatives. Simple (naive) models often perform well, especially on financial data. Our naive serves a baseline to compare Model 1 and 2. If the naive performs closely to first two, the naive model should be preferred.</p>
<p>The naive model doesn’t require training and test sets, but to compare its performance with the other two models, forecasts are made only on the test set dates from the the first two models. We want all models to be compared on the same data.</p>
<pre class="r"><code># include lag 1 of cnt variable
b3 &lt;- b2 %&gt;% mutate(cnt_1 = lag(cnt)) %&gt;% filter(complete.cases(.))
# time slices are the same as in model 2
# use the test indices
rmsle_naive &lt;- c()
smape_naive &lt;- c()
rmse_naive &lt;- c()
for (i in 1:n_mods) {
  indices &lt;- bike_splits2$test[[i]]
  actual &lt;- b3[indices, &quot;cnt&quot;]
  naive_preds &lt;- b3[indices, &quot;cnt_1&quot;]
  rmsle_naive &lt;- append(rmsle_naive, Metrics::rmsle(actual, naive_preds))
  smape_naive &lt;- append(smape_naive, Metrics::smape(actual, naive_preds))
  rmse_naive &lt;- append(rmse_naive, Metrics::rmse(actual, naive_preds))
  }

# Median Naive RMSE
paste0(&quot;Median RMSE: &quot;, round(median(rmse_naive),3))</code></pre>
<pre><code>[1] &quot;Median RMSE: 2715.094&quot;</code></pre>
<pre class="r"><code># Mean Naive RMSLE
paste0(&quot;Mean RMSLE: &quot;, round(mean(rmsle_naive),3))</code></pre>
<pre><code>[1] &quot;Mean RMSLE: 0.338&quot;</code></pre>
<pre class="r"><code># Median Naive SMAPE
paste0(&quot;Median SMAPE: &quot;, round(median(smape_naive), 2))</code></pre>
<pre><code>[1] &quot;Median SMAPE: 0.23&quot;</code></pre>
<p>The naive model fares rather poorly compared to the other two models on all three performance metrics.</p>
</div>
<div id="comments-on-model-performance" class="section level2">
<h2>Comments on Model Performance</h2>
<p>Each model and its performance in the following table. Gradient boosting affords the highest accuracies on all performance metrics but is the least interpretable since each tree in gradient boosting is different, and 5000 were used in each training iteration! Volatility in daily trip numbers means relying purely on calendar and weather variables may not be sufficient for attaining higher accuracies (or lower RMSEs). For instance (as mentioned earlier) the annual National Cherry Blossom Festival is not consistent year to year, and ridership on those days isn’t easily predicted. The volatility can be seen in the numerous ridership dips in 2017, presented in the plot below. Inclusion of other variables mentioned in the <a href="#literature-review">Literature Review</a> may help improve forecasts and could be used in future research.</p>
<table class="table table-striped" style="width: auto !important; margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;">
Model
</th>
<th style="text-align:left;">
Median % Accuracy
</th>
<th style="text-align:right;">
Median RMSE
</th>
<th style="text-align:right;">
Mean RMSLE
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Naive (Baseline)
</td>
<td style="text-align:left;">
77%
</td>
<td style="text-align:right;">
2715
</td>
<td style="text-align:right;">
0.338
</td>
</tr>
<tr>
<td style="text-align:left;">
MLR w/ Correlated Errors
</td>
<td style="text-align:left;">
81%
</td>
<td style="text-align:right;">
2302
</td>
<td style="text-align:right;">
0.270
</td>
</tr>
<tr>
<td style="text-align:left;font-weight: bold;color: white !important;background-color: green !important;">
Gradient Boosted Regression Trees
</td>
<td style="text-align:left;font-weight: bold;color: white !important;background-color: green !important;">
87%
</td>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: green !important;">
1642
</td>
<td style="text-align:right;font-weight: bold;color: white !important;background-color: green !important;">
0.200
</td>
</tr>
</tbody>
</table>
<pre class="r"><code>bikes %&gt;% filter(between(TripDate, &quot;2017/01/01&quot;, &quot;2017/12/31&quot;)) -&gt; bikes_2017

ggplot(bikes_2017, aes(TripDate,cnt)) + 
  geom_line(col=&quot;steelblue&quot;) +
  xlab(&quot;&quot;)+
  ylab(&quot;Total Trips&quot;)+
  scale_x_date(breaks = &quot;3 months&quot;) +
  ggtitle(&quot;Capital BikeShare Daily Trips (2017)&quot;) +
  theme(panel.grid = element_blank(),
        plot.title = element_text(hjust=0.5, family = &quot;Georgia&quot;))</code></pre>
<p><img src="/project/2020-04-02-forecasting-capital-bikeshare-ridership_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
</div>
<div id="further-research" class="section level2">
<h2>Further Research</h2>
<p>This analysis focuses on overall ridership numbers regardless of membership type (casual or registered). To predict revenue by membership type we could calculate the proportion of persons belonging to each category from historical data (say, from 2016) as an estimate. Future research can involve forecasting registered and casual ridership numbers separately, combining their forecasts for predicted overall ridership. This in itself still wouldn’t help determine revenue by membership type since memberships are broken down by <a href="https://www.capitalbikeshare.com/pricing">five different plan types</a> not provided in the dataset, though CB officials would theoretically have such information.</p>
<p>Other research can involve station-level forecasting and use of other model techniques like neural networks.</p>
</div>
<div id="conclusion" class="section level2">
<h2>Conclusion</h2>
<p>We examine three competing forecasting models for 30-day ahead bike share ridership for Washington DC’s Capital BikeShare program, the best model being gradient boosted regression trees. It also improves on the best previous research by reducing the number of variables used for regression, with only 8 unique variables are used here compared to 17 by Wang et al. This work can serve as a starting point for refining forecast accuracy at the station level.</p>
</div>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

